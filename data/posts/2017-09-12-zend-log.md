---
layout: post
title: Logging PHP applications
date: 2017-09-12T11:24:00-05:00
author: Enrico Zimuel
url_author: https://www.zimuel.it
permalink: /blog/2017-09-12-zend-log.html
categories:
- blog
- psr3
- log
- zend-log

---

Every PHP application generates errors, warnings, notices and throws exceptions.
If we do not store these information in a log system, we are losing a way
to identify and solve problems at runtime. Moreover, we may need to log specific
actions like a user's login and logout. All these information should be filtered
and stored in an efficient way.

PHP offers the functions [error_log()](http://php.net/manual/en/function.error-log.php)
to send an error message to the defined log system and [set_error_handler()](http://php.net/manual/en/function.set-error-handler.php)
to intercept the warnings, errors, and notices generated by PHP.

These functions can be used to customize the error management but it's up to the
developer to write the logic to filter and store the data.

Zend Framework offers a specific component for logging, [zend-log](https://github.com/zendframework/zend-log). This library can be used
as general purpose logging system. It supports multiple log backends, formatting
messages sent to the log, and filtering messages from being logged.

Last but not least, `zend-log` is compliant with the [PSR-3](http://www.php-fig.org/psr/psr-3/)
logger interface standard.

## Installation

You can install [zend-log](https://github.com/zendframework/zend-log) using the
following [composer](https://getcomposer.org) command:

```bash
composer require zendframework/zend-log
```

## Usage

Zend-log can be used to write log in different formats using multiple backends.
You can also filter the log data from being saved and processes the log event
prior to filtering or writing, allowing the ability to substitute, add, remove,
or modify data to be logged.

To use `zend-log` you need tp have at least a writer and a logger instance.
The writer performs the storage of the log into a backend, and the logger
consumes the writer to perform the log.

A usage example is reported as follows:

```php
use Zend\Log\Logger;
use Zend\Log\Writer\Stream;

$logger = new Logger;
$writer = new Stream('php://output');

$logger->addWriter($writer);
$logger->log(Logger::INFO, 'Informational message');
```

An example of output is reported as follows:

```
2017-09-11T15:07:46+02:00 INFO (6): Informational message
```

The output is a string containing a timestamp, a priority `INFO (6)` and the
message `Informational message`. The output format can be changed using the
`setFormatter()` function of the writer object (`$writer`).
The default log format, used by [Simple](https://github.com/zendframework/zend-log/blob/master/src/Formatter/Simple.php)
formatter is as follows:

```
%timestamp% %priorityName% (%priority%): %message% %extra%
```

where `%extra%` is an optional value containing additional info.

For instance, to change the format using the `log %message%` string you can use
the following code:

```php
$formatter = new Zend\Log\Formatter\Simple('log %message%' . PHP_EOL);
$writer->setFormatter($formatter);
```

## Log PHP events

Zend-log can also be used to log PHP errors and intercept exceptions. You can
log PHP errors using the static function `registerErrorHandler($logger)` and
intercept exceptions using the static function `registerExceptionHandler($logger)`.

An example is reported as follows:

```php
use Zend\Log\Logger;
use Zend\Log\Writer;

$logger = new Logger;
$writer = new Writer\Stream(__DIR__ . '/test.log');
$logger->addWriter($writer);

// Log PHP errors
Logger::registerErrorHandler($logger);
// Log exceptions
Logger::registerExceptionHandler($logger);
```

## Filtering data

As mentioned, we can filter the data to be logged. We can use the `addFilter()`
functions of the [Writer interface](https://github.com/zendframework/zend-log/blob/master/src/Writer/WriterInterface.php)
to add a specific filter.

For instance, we can filter by priority, accepting only log with priority less
than or equal to a specific value. An example is reported as follows:

```php
$filter = new Zend\Log\Filter\Priority(Logger::CRIT);
$writer->addFilter($filter);
```

Using this example, the logger will store only the log with priority less or
equal to *Critical*. The priorities are defined by the `Zend\Log\Logger` class:

```
EMERG   = 0;  // Emergency: system is unusable
ALERT   = 1;  // Alert: action must be taken immediately
CRIT    = 2;  // Critical: critical conditions
ERR     = 3;  // Error: error conditions
WARN    = 4;  // Warning: warning conditions
NOTICE  = 5;  // Notice: normal but significant condition
INFO    = 6;  // Informational: informational messages
DEBUG   = 7;  // Debug: debug messages
```

We can also filter log data based on regular expressions, timestamp, etc.
Moreover, we can use a [zend-validator](https://github.com/zendframework/zend-validator)
class to filter the log or implementing a custom `Zend\Validator\ValidatorInterface`.

## Processing data

If you need to provide additional information to logs in an automated fashion,
you can use a `Zend\Log\Processer` class. A processor is executed before the
log data are passed to the writer. The input of a processor is a *log event*,
an array containing all the information log. The output is still a *log event*.
The processor can modify the *log event* before it sent to the writer.

You can read about the processor adapters offered by zend-log [here](https://zendframework.github.io/zend-log/processors/)
in the documentation.

## Multiple backends

One of the cool feature of `zend-log` is the possibility to write log using
multiple backends. For instance, you can write a log in a file and in a
database using the following code:

```php
use Zend\Db\Adapter\Adapter as DbAdapter;
use Zend\Log\Formatter;
use Zend\Log\Writer;
use Zend\Log\Logger;

$dbconfig = [
    'driver' => 'Pdo',
    'dsn' => 'mysql:dbname=testlog;host=localhost',
    'username' => 'root',
    'password' => 'password'
];
$db = new DbAdapter($dbconfig);
$mapping = [
    'timestamp' => 'date',
    'priority'  => 'type',
    'message'   => 'event',
];
$writer1 = new Writer\Db($db, 'log', $mapping); // log table
$formatter = new Formatter\Base();
$formatter->setDateTimeFormat("Y-m-d H:i:s"); // MySQL DATETIME format
$writer1->setFormatter($formatter);

$writer2 = new Writer\Stream(__DIR__ . '/test.log');

$logger = new Logger();
$logger->addWriter($writer1, 1);
$logger->addWriter($writer2, 100);

$logger->info('Informational message');
```

The database writer requires the credentials to access the table where to
store the log information. You can customize the field name for the db table
using a `$mapping` array, containing an associative array to map the log fields
into the database fields.

The database writer is composed in `$writer1` and the file writer in `$writer2`.
The writers are added to the logger using the `addWriter()` function with a
priority number, higher integer values indicate higher priority (triggered
earliest). We chosen priority 1 for database and priority 100 for file, this
means the log will be added to the file first, following the storage in the
database.

> Note: we used a special date formatter for the database writer. This is
> required to translate the log timestamp into the DATETIME format of MySQL.

## PSR-3 support

If you need to be compatible with [PSR-3]([PSR-3](http://www.php-fig.org/psr/psr-3/)),
you can use the `Zend\Log\PsrLoggerAdapter`. This logger can be used anywhere
a `Psr\Log\LoggerInterface` is expected.

An example is reported as follows:

```php
$zendLogLogger = new Zend\Log\Logger;

$psrLogger = new Zend\Log\PsrLoggerAdapter($zendLogLogger);
$psrLogger->log(Psr\Log\LogLevel::INFO, 'We have a PSR-compatible logger');
```

To select a PSR-3 backend for writing, we can use the `Zend\Log\Writer\Psr`
class. In order to use it, you need to pass the $psrLogger.

For instance, here is reported an example passing the logger in constructor:

```php
$writer = new Zend\Log\Writer\Psr($psrLogger);
```

Zend-log supports also the [PSR-3 message placeholders](https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-3-logger-interface.md#12-message)
with the `Zend\Log\Processor\PsrPlaceholder` class. The usage is straightforward,
you need to add the `PsrPlaceholder` to a logger, using the `addProcess()`
function. Placeholder names correspond to keys in the "extra" array passed
when logging a message. An example is reported as follows:

```php
use Zend\Log\Logger;
use Zend\Log\Processor\PsrPlaceholder;

$logger = new Logger;
$logger->addProcessor(new PsrPlaceholder);

$logger->info('User with email {email} registered', ['email' => 'user@example.org']);
```

An info log will be stored with message `User with email user@example.org registered`.


## Logging an MVC application

If you are using a [zend-mvc](https://github.com/zendframework/zend-mvc) based
application you can use `zend-log` as module. Zend-log provides a [Module.php](https://github.com/zendframework/zend-log/blob/master/src/Module.php)
class, ready to register `Zend\Log` as a module in your application.

<a name="zend-log-services"></a>
In particular, the `zend-log` module will provide the following services (under
the namespace `Zend\Log`):

```
Logger::class         => LoggerServiceFactory::class,
'LogFilterManager'    => FilterPluginManagerFactory::class,
'LogFormatterManager' => FormatterPluginManagerFactory::class,
'LogProcessorManager' => ProcessorPluginManagerFactory::class,
'LogWriterManager'    => WriterPluginManagerFactory::class,
```

The `Logger::class` service can be configured using the `log` key in the config
file. An [example](http://zendframework.github.io/zend-log/service-manager/#zend-log-as-a-module)
is reported in the documentation.

In order to use the Logger service in your MVC stack, you just need to grab it
from the service container. For instance, you can pass the *Logger service* in a
controller using a `FactoryInterface`:

```php
use Zend\Log\Logger;
use Zend\ServiceManager\Factory\FactoryInterface;

class IndexControllerFactory implements FactoryInterface
{
    public function __invoke(
        ContainerInterface $container,
        $requestedName,
        array $options = null
    ) {
        return new IndexController(
            $container->get(Logger::class)
        );
    }
}
```
Using the following configuration for the *Index controller*:

```php
'controllers' => [
    'factories' => [
        Controller\IndexController::class => Controller\IndexControllerFactory::class,
    ],
],
```

## Logging a middleware application

Use `zend-log` in a middleware application is very easy. If you are using
[Expressive](http://zendframework.github.io/zend-expressive/), you just need to
add the [ConfigProvider](https://github.com/zendframework/zend-log/blob/master/src/ConfigProvider.php)
class in your `config/config.php` file.

> Note: if you are using [zend-component-installer](https://github.com/zendframework/zend-component-installer/),
> you will have been prompted to install `zend-log` as a module, injecting
> `Zend\Log\ConfigProvider` in `config/config.php`, when you install the
> component.

> Note:
This configuration will register the [same services](#zend-log-services)
provided before, in the MVC example.

To use `zend-log` in a middleware, you just need to grab it from the service
container and pass as dependency. An example is reported as follows, using a `HomeActionFactory`:

```php
namespace App\Action;

use Psr\Container\ContainerInterface;
use Zend\Log\Logger;

class HomeActionFactory
{
    public function __invoke(ContainerInterface $container) : HomeAction
    {
        return new HomeAction(
            $container->get(Logger::class)
        );
    }
}
```

and a `HomeAction` middleware:

```php
namespace App\Action;

use Interop\Http\ServerMiddleware\DelegateInterface;
use Interop\Http\ServerMiddleware\MiddlewareInterface as ServerMiddlewareInterface;
use Psr\Http\Message\ServerRequestInterface;
use Zend\Log\Logger;

class HomeAction implements ServerMiddlewareInterface
{
    private $logger;

    public function __construct(Logger $logger)
    {
        $this->logger = logger;
    }

    public function process(
        ServerRequestInterface $request,
        DelegateInterface $delegate
    ) {
        $this->logger->log(Logger::INFO, __CLASS__ . ' has been executed');

        // ...
    }
}
```

## Summary

We discussed about the usage of `zend-log` a components of [Zend Framework](https://framework.zend.com/)
used to log PHP applications. This component offers a wide set of features
including the support of multiple writers, the filtering of log data, the
compatibility with [PSR-3](http://www.php-fig.org/psr/psr-3/) standard, and
more.

We also provided a couple of examples for consuming `zend-log` in an MVC or
middleware application. As well as for other Zend components, you can use
`zend-log` with or without [Zend Framework](https://framework.zend.com/).

You can check out more in the [zend-log documentation](https://zendframework.github.io/zend-log/).
