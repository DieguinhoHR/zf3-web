---
layout: issue
title: "Support sequences and natural keys on insert()"
id: ZF-1140
---

ZF-1140: Support sequences and natural keys on insert()
-------------------------------------------------------

 Issue Type: Improvement Created: 2007-03-26T16:05:21.000+0000 Last Updated: 2007-07-05T14:43:59.000+0000 Status: Resolved Fix version(s): - 0.9.3 (05/May/07)
 
 Reporter:  Bill Karwin (bkarwin)  Assignee:  Bill Karwin (bkarwin)  Tags: - Zend\_Db\_Table
 
 Related issues: - [ZF-78](/issues/browse/ZF-78)
 
 Attachments: 
### Description

Oracle, DB2, and PostgreSQL use sequences instead of auto-increment or identity columns.

But Zend\_Db\_Table assumes that after an INSERT, the lastInsertId() method returns the most recently generated value for the current table.

This improvement consists of the following: - Define abstract methods lastSequenceId() and nextSequenceId() in the Zend\_Db\_Adapter\_Abstract class. Adapters that do not support sequences should throw an exception if these methods are called. - In Zend\_Db\_Table\_Abstract, add a protected class variable $\_sequence. If this is Boolean true, then use auto-increment; if this is boolean false, then user is responsible for setting primary key values (throw exception if no values specified); if this is a string, use this as the name of the sequence in the Zend\_Db\_Table::insert() method, generate a value, use it in the INSERT, and return it from insert().

The default value of $\_sequence is true, for backward compatibility (and probably the more common cases).

In PostgreSQL and Oracle, which require named sequences, the user must define the sequence by setting $\_sequence to a string value in his Table class, or else the variable must be Boolean false.

In DB2, which permits either explicit named sequences or else the table DDL can include the name of a sequence to use for generating values, the user may define $\_sequence to a name, or else he may set it to Boolean values true or false.

In Microsoft SQL Server, MySQL, and SQLite, the user may only set the $\_sequence variable to Boolean values true or false.

 

 

### Comments

Posted by Bryce Lohr (gearhead) on 2007-04-03T12:47:00.000+0000

Currently, Zend\_Db\_Adapter\_Abstract::lastInsertId() has optional parameters. The Pgsql adapter class uses these optional parameters to effectively define the sequence name to use. So, calling lastInsertId() will return the last value used by the given sequence. Do the improvements suggested in this issue break or change the current behavior?

 

 

Posted by Bill Karwin (bkarwin) on 2007-04-03T14:09:47.000+0000

There should be no breakage to current functionality. The proposed solution would add new methods lastSequenceId($sequenceName) and nextSequenceId($sequenceName).

The behavior of the current lastInsertId([$tableName, [$primaryKey]]) would allow the arguments to form a sequence name by the current conventional format, and then call lastSequenceId() with the synthesized sequence name.

But in addition, if you have a sequence with a name that doesn't match the conventional format, you can call lastSequenceId() directly, passing the name of your sequence.

The behavior in the Zend\_Db\_Table\_Abstract::insert() method would be to call lastSequenceId() directly, if is\_string($this->\_sequence) is true. So in your table class, you'd have to declare the name of the sequence explicitly. This also would not break backward compatibility, because the way it is implemented currently, I don't think the Table class's insert() method can work with PostgreSQL/Oracle/DB2 anyway.

 

 

Posted by Bill Karwin (bkarwin) on 2007-04-03T15:16:30.000+0000

Revision 4335 contains some clean-up to the lastInsertId() method, and new methods lastSequenceId() and nextSequenceId().

 

 

Posted by Manuel Ferreira (mfcn) on 2007-04-12T14:02:54.000+0000

I guess the value of $\_sequencename attribute may be defined in method Zend\_Db\_Adapter\_Pdo\_Pgsql::describeTable() changing the string sql to add the sequence name of primary key as below:

 
    <pre class="highlight">
    public function describeTable($tableName, $schemaName = null)
        {
            $sql = "SELECT
                    a.attnum,
                    n.nspname,
                    c.relname,
                    a.attname AS colname,
                    t.typname AS type,
                    a.atttypmod,
                    FORMAT_TYPE(a.atttypid, a.atttypmod) AS complete_type,
                    d.adsrc AS default_value,
                    a.attnotnull AS notnull,
                    a.attlen AS length,
                    co.contype,
                    ARRAY_TO_STRING(co.conkey, ',') AS conkey,
    +             CASE WHEN co.contype = 'p' THEN
    +                          (SELECT relname FROM pg_class WHERE reltype = (CAST(a.attrelid AS int) - 1))
    +             ELSE ''
    +             END AS sequencename
                FROM pg_attribute AS a
                    JOIN pg_class AS c ON a.attrelid = c.oid
                    JOIN pg_namespace AS n ON c.relnamespace = n.oid
                    JOIN pg_type AS t ON a.atttypid = t.oid
                    LEFT OUTER JOIN pg_constraint AS co ON (co.conrelid = c.oid
                        AND a.attnum = ANY(co.conkey) AND co.contype = 'p')
                    LEFT OUTER JOIN pg_attrdef AS d ON d.adrelid = c.oid AND d.adnum = a.attnum
                WHERE a.attnum > 0 AND c.relname = ".$this->quote($tableName);
    
            if ($schemaName) {
                $sql .= " AND n.nspname = ".$this->quote($schemaName);
            }
            ...
    }
    


 

 

Posted by Bill Karwin (bkarwin) on 2007-05-01T13:34:27.000+0000

Revisions 4642, 4643, 4644, 4645 contain code and unit tests to support sequences for Oracle, PostgreSQL, and DB2.

There are still some stubbed-out unit tests for supporting natural keys.

 

 

Posted by Bill Karwin (bkarwin) on 2007-05-01T15:57:03.000+0000

Manuel, I guess the change you show is meant to use a sequence that is "owned" by a specific column of a specific table, as would be created implicitly by declaring a column with the SERIAL pseudotype.

My understanding is that it is not necessary to gather this information; if you are using an implicitly-created sequence with a SERIAL column, simply insert NULL to the column or omit the column from the column-list in an INSERT. The sequence is invoked automatically by the PostgreSQL server and the next value is generated.

The usage that I'm implementing to declare the name of the sequence as a string is intended for cases where you do not have a SERIAL column, but instead you are using a sequence _explicitly_. This matches typical usage in Oracle, for example. It's useful if you want one sequence to generate values for multiple tables.

 

 

Posted by Bill Karwin (bkarwin) on 2007-05-03T17:26:17.000+0000

This is now complete. As of revision 4697.

 

 