---
layout: issue
title: "Create consistences to test before invoking array_key_exists on Adapter.php Line 398"
id: ZF-3314
---

ZF-3314: Create consistences to test before invoking array\_key\_exists on Adapter.php Line 398
-----------------------------------------------------------------------------------------------

 Issue Type: Improvement Created: 2008-05-22T22:53:44.000+0000 Last Updated: 2008-05-24T13:41:51.000+0000 Status: Resolved Fix version(s): 
 Reporter:  Ramses Paiva (rpaiva)  Assignee:  Thomas Weidner (thomas)  Tags: - Zend\_Translate
 
 Related issues: 
 Attachments: 
### Description

To avoid the warning below, it's needed to create consistences testing if the $messageId really is an integer or a string.

Warning: array\_key\_exists(): The first argument should be either a string or an integer in \\Zend\\Translate\\Adapter.php on line 398

Maybe using is\_string() and is\_int() PHP functions like below:

 
    <pre class="highlight">
        /**
         * Translates the given string
         * returns the translation
         *
         * @param  string              $messageId  Translation string
         * @param  string|Zend_Locale  $locale     OPTIONAL Locale/Language to use, identical with locale identifier,
         *                                         see Zend_Locale for more information
         * @return string
         */
        public function translate($messageId, $locale = null)
        {
            if ($locale === null) {
                $locale = $this->_options['locale'];
            }
    
            if (!$locale = Zend_Locale::isLocale($locale)) {
                // language does not exist, return original string
                return $messageId;
            }
    
            if ((is_array($this->_translate) and array_key_exists($locale, $this->_translate)) and
                (is_string($messageId) or is_int($messageId)) and
                (is_array($this->_translate[$locale]) and array_key_exists($messageId, $this->_translate[$locale]))) {
                // return original translation
                return $this->_translate[$locale][$messageId];
            } else if (strlen($locale) != 2) {
                // faster than creating a new locale and separate the leading part
                $locale = substr($locale, 0, -strlen(strrchr($locale, '_')));
    
                if ((is_array($this->_translate) and array_key_exists($locale, $this->_translate)) and
                    (is_string($messageId) or is_int($messageId)) and
                    (is_array($this->_translate[$locale]) and array_key_exists($messageId, $this->_translate[$locale]))) {
                    // return regionless translation (en_US -> en)
                    return $this->_translate[$locale][$messageId];
                }
            }
    
            // no translation found, return original
            return $messageId;
        }


 

 

### Comments

Posted by Ramses Paiva (rpaiva) on 2008-05-22T22:56:42.000+0000

My suggestion would implement the code like this:

 
    /**
     * Translates the given string
     * returns the translation
     *
     * @param  string              $messageId  Translation string
     * @param  string|Zend_Locale  $locale     OPTIONAL Locale/Language to use, identical with locale identifier,
     *                                         see Zend_Locale for more information
     * @return string
     */
    public function translate($messageId, $locale = null)
    {
        if ($locale === null) {
            $locale = $this->_options['locale'];
        }
    
        if (!$locale = Zend_Locale::isLocale($locale)) {
            // language does not exist, return original string
            return $messageId;
        }
    
        if ((is_array($this->_translate) and array_key_exists($locale, $this->_translate)) and
            (is_string($messageId) or is_int($messageId)) and
            (is_array($this->_translate[$locale]) and array_key_exists($messageId, $this->_translate[$locale]))) {
            // return original translation
            return $this->_translate[$locale][$messageId];
        } else if (strlen($locale) != 2) {
            // faster than creating a new locale and separate the leading part
            $locale = substr($locale, 0, -strlen(strrchr($locale, '_')));
    
            if ((is_array($this->_translate) and array_key_exists($locale, $this->_translate)) and
                (is_string($messageId) or is_int($messageId)) and
                (is_array($this->_translate[$locale]) and array_key_exists($messageId, $this->_translate[$locale]))) {
                // return regionless translation (en_US -> en)
                return $this->_translate[$locale][$messageId];
            }
        }
    
        // no translation found, return original
        return $messageId;
    }


 

 

Posted by Thomas Weidner (thomas) on 2008-05-23T00:11:21.000+0000

This issue has already been fixed several months ago and was integrated within 1.5.2

 

 

Posted by Ramses Paiva (rpaiva) on 2008-05-24T11:47:33.000+0000

Hi, Thomas! Yes, I just saw it. You're using is\_array() to test the param's type. But I still believe that would be better to use is\_string() combined to is\_int() to validate it, because you could receive other invalid types in the function that could be not an array type, like an object, for example. Then you fix the param only for the valid types to be received on the next tests. What about?

Here, an example:

 
    <pre class="highlight">
    if (!(is_string($messageId) or !is_int($messageId))) {
        return $messageId;
    }


 

 

Posted by Thomas Weidner (thomas) on 2008-05-24T13:41:51.000+0000

Still no issue...

When you give an issue the \_\_toString method will automatically be called. This is better than involving several other checks.

You must have in mind that this is the base method for all translations and when you have a multilingual application you will have really much translations. And even with the two checks (which are useless in my eyes) you will still not have the expected output.

When you give a object you will get exactly this object returned as it's not translatable. So you will have problems anyway.

Translation itself MUST NOT RETURN EXCEPTIONS !!! If anything goes wrong we MUST return the input as output which is done in case of an object. You will get the object returned.

 

 